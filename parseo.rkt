#lang racket
(require "js-structures.rkt" "faster-miniKanren/mk.rkt" "evalo.rkt" "helpers.rkt")
(provide hoist-varo humanize dehumanize parseo/readable parseo)

; Parse a JavaScript statement with human-readable literals
(define (parseo/readable stmt jexpr)
  (parseo (dehumanize stmt) jexpr))

; Parse a JavaScript statement with relational number and string literals
(define (parseo stmt jexpr)
  (fresh (vars exp^ allocations body)
         (hoist-varo stmt vars)
         (allocato vars body jexpr)
         (parse-envo stmt body vars)))

; Parse a JavaScript statement to LambdaJS expression passing the env
(define (parse-envo stmt jexpr env)
  (conde
    ; expressions have a helper for their own
    ((parse-exp-envo stmt jexpr env))
    ; begin statement (Section 3.2.7)
    ((fresh (stmts jexprs begin-jexpr)
       (== stmt `(begin . ,stmts))
       (== jexpr (jbeg begin-jexpr (jundef)))
       (parse-env-listo stmts jexprs env)
       (begino jexprs begin-jexpr)))
    ; if statement  (Section 3.2.7)
    ((fresh (cond-expr then-stmt else-stmt cond-jexpr then-jexpr else-jexpr)
       (== stmt `(if ,cond-expr ,then-stmt ,else-stmt))
       (== jexpr (jbeg (jif cond-jexpr then-jexpr else-jexpr) (jundef)))
       (parse-exp-envo cond-expr cond-jexpr env)
       (parse-env-listo `(,then-stmt ,else-stmt)
                        `(,then-jexpr ,else-jexpr)
                        env)))
    ; variable declaration (Section 3.2.1)
    ((fresh (vars bindings assignments-jexpr)
       (== stmt `(var . ,vars))
       (hoist-pairso vars bindings)
       (conde ((== bindings `()) (== jexpr (jundef)))
              ((== jexpr (jbeg assignments-jexpr (jundef)))
               (=/= bindings `())
               (pair-assigno bindings assignments-jexpr env)))))
    ; for loops (Section 3.2.7)
    ((fresh (init-stmt init-jexpr
             cond-expr cond-jexpr
             inc-expr inc-jexpr
             body-stmts body-jexprs body-jexpr)
       (== stmt `(for (,init-stmt ,cond-expr ,inc-expr) . ,body-stmts))
       (== jexpr (jbeg init-jexpr
                       (jcatch `break
                               (jwhile cond-jexpr (jbeg body-jexpr inc-jexpr))
                               `e
                               (jundef))))
       (parse-exp-env-listo `(,cond-expr ,inc-expr) `(,cond-jexpr ,inc-jexpr) env)
       (parse-envo init-stmt init-jexpr env)
       (parse-env-listo body-stmts body-jexprs env)
       (begino body-jexprs body-jexpr)))
    ; return control effect (Section 3.2.8)
    ((fresh (val-expr val-jexpr)
       (== stmt `(return ,val-expr))
       (== jexpr (jthrow `return val-jexpr))
       (parse-exp-envo val-expr val-jexpr env)))
    ; throw control effect (Section 3.2.8)
    ((fresh (val-expr val-jexpr)  ;; throw
       (== stmt `(throw ,val-expr))
       (== jexpr (jthrow `error val-jexpr))
       (parse-exp-envo val-expr val-jexpr env)))
    ; break control effect (Section 3.2.8)
    ((== stmt `(break)) (== jexpr (jthrow `break (jundef))))
    ; try/catch control effect (Section 3.2.8)
    ((fresh (try-stmt try-jexpr catch-stmt catch-jexpr catch-var catch-env)
       (== stmt `(try ,try-stmt catch ,catch-var ,catch-stmt))
       (== jexpr
           (jbeg (jcatch `error try-jexpr catch-var
                         (jlet catch-var (jall (jvar catch-var)) catch-jexpr))
                 (jundef)))
       (== catch-env `(,catch-var . ,env))
       (parse-envo try-stmt try-jexpr env)
       (parse-envo catch-stmt catch-jexpr catch-env)))
    ; try/finally control effect (Section 3.2.8)
    ((fresh (try-stmt try-jexpr finally-stmt finally-jexpr)
       (== stmt `(try ,try-stmt finally ,finally-stmt))
       (== jexpr (jfin try-jexpr (jbeg finally-jexpr (jundef))))
       (parse-envo try-stmt try-jexpr env)
       (parse-envo finally-stmt finally-jexpr env)))
    ; try/catch/finally control effect (Section 3.2.8)
    ((fresh (try-stmt try-jexpr
             catch-stmt catch-jexpr catch-var catch-env
             finally-stmt finally-jexpr)
       (== stmt `(try ,try-stmt
                  catch ,catch-var ,catch-stmt
                  finally ,finally-stmt))
       (== jexpr (jbeg (jcatch `error try-jexpr catch-var catch-jexpr)
                       (jbeg finally-jexpr (jundef))))
       (== catch-env `(,catch-var . ,env))
       (parse-envo try-stmt try-jexpr env)
       (parse-envo catch-stmt catch-jexpr catch-env)
       (parse-envo finally-stmt finally-jexpr env)))
    ; while statements (Section 3.2.7)
    ((fresh (cond-expr cond-jexpr body-stmts body-jexprs body-jexpr)
       (== stmt `(while ,cond-expr . ,body-stmts))
       (== jexpr (jcatch `break (jwhile cond-jexpr body-jexpr) `e (jundef)))
       (parse-exp-envo cond-expr cond-jexpr env)
       (parse-env-listo body-stmts body-jexprs env)
       (begino body-jexprs body-jexpr)))))

(define (parse-exp-envo stmt jexpr env)
  (conde
   ;; Variables
   ((symbolo stmt ) (== jexpr (jderef (jvar stmt ))))
   ;; Simple literals
   ((conde ((== stmt jexpr) (fresh (x) (conde ((== stmt `(number ,x)))
                                            ((== stmt `(string ,x))))))
           ((== stmt #t) (== jexpr (jbool #t)))
           ((== stmt #f) (== jexpr (jbool #f)))
           ((== stmt (jnul)) (== jexpr (jnul)))
           ((== stmt (jundef)) (== jexpr (jundef)))))
   ;; Primitive operations
   ((fresh (op vals vals^)
           (== stmt `(op ,op . ,vals))
           (== jexpr (jdelta op vals^))
           (parse-exp-env-listo vals vals^ env)))
   ;; Assignment
   ((fresh (var val var^ val^)
           (== stmt `(:= ,var ,val))
           (conde ((symbolo var) (== jexpr (jassign (jvar var) val^)))
                  ((fresh (obj obj^ key key^ obj-parsed temp-var)
                          (== var `(@ ,obj ,key))
                          (== obj-parsed (jvar obj))
                          (symbolo temp-var)
                          (not-in-listo temp-var env)
                          (== jexpr (jbeg
                                    (jlet
                                     temp-var
                                     (jset (jderef obj^) (jstr "public") (jset (jget (jderef obj^) (jstr "public")) key^ val^))
                                     (jassign obj^ (jvar temp-var)))
                                    val^))
                          (parse-exp-env-listo `(,key ,obj) `(,key^ ,obj^) env))))
           (parse-exp-envo val val^ env)))
   ;; Field access
   ((fresh (val val^ index index^)
           (== stmt `(@ ,val ,index))
           (== jexpr (jget (jget (jderef val^) (jstr "public")) index^))
           (parse-exp-env-listo `(,val ,index) `(,val^ ,index^) env)))
   ;; Function call
   ((fresh (func args func^ args^)
           (== stmt `(call ,func . ,args))
           (== jexpr (japp (jget (jget (jderef func^) (jstr "private")) (jstr "call")) args^))
           (parse-exp-env-listo `(,func . ,args) `(,func^ . ,args^) env)))
   ((objecto stmt jexpr env))
   ((functiono stmt jexpr env))
   ;; Comma expression sequencing
   ((fresh (exps exps^)
           (== stmt `(comma . ,exps))
           (parse-exp-env-listo exps exps^ env)
           (begino exps^ jexpr)))))

(define (parse-env-listo lst jlst env)
  (conde ((== lst `()) (== jlst `()))
         ((fresh (p p^ rest rest^)
                 (== lst `(,p . ,rest))
                 (== jlst `(,p^ . ,rest^))
                 (parse-envo p p^ env)
                 (parse-env-listo rest rest^ env)
                 ))))

(define (parse-exp-env-listo lst jlst env)
  (conde ((== lst `()) (== jlst `()))
         ((fresh (p p^ rest rest^)
                 (== lst `(,p . ,rest))
                 (== jlst `(,p^ . ,rest^))
                 (parse-exp-envo p p^ env)
                 (parse-exp-env-listo rest rest^ env)
                 ))))


(define (lh-parseo stmt jexpr env)
  (conde ((symbolo stmt ) (== jexpr (jvar stmt )))
         ((fresh (obj obj^ val val^)
                 (== stmt `(@ ,obj ,val))
                 (== jexpr (jget (jget obj^ (jstr "public")) val^))
                 (parse-exp-env-listo `(,obj ,val) `(,obj^ ,val^) env)))))

(define (objecto stmt jexpr env)
  (fresh (pairs public)
         (== stmt `(object . ,pairs))
         (== jexpr (jall (jset (jobj (list (cons (jstr "private") (jobj `())))) (jstr "public") public)))
         (object-helpero pairs public env)
         ))

(define (object-helpero exp-binds jexpr env)
  (conde ((== exp-binds `()) (== jexpr (jobj `())))
         ((fresh (key val key^ val^ rest prev curr)
                 (== exp-binds `((,key ,val) . ,rest))
                 (== jexpr (jset prev key^ val^))
                 (parse-exp-env-listo `(,key ,val) `(,key^ ,val^) env)
                 (object-helpero rest prev env)))))


(define (functiono stmt jexpr env)
  (fresh (params body body^ body^^ body^^^ body^^^^ vars vars^ payload env^ env^^ return-var)
         (== stmt `(function ,params . ,body))
         (== jexpr (jall (jset (jobj `((,(jstr "public") . ,(jobj `()))))
                              (jstr "private")
                              (jset (jobj `()) (jstr "call")
                                    (jfun params
                                          (jcatch `return (jbeg body^^^^ (jundef))
                                                  'result (jvar 'result)))))))
         (hoist-var-listo body vars)
         (differenceo vars params vars^)
         (appendo vars^ env env^)
         (appendo params env^ env^^)
         (parse-env-listo body body^ env^^)
         (begino body^ body^^)
         (allocato vars^ body^^ body^^^)
         (assigno params body^^^ body^^^^)
         ))

(define (differenceo list1 list2 result)
  (conde ((== list1 `())
          (== result list1))
         ((fresh (el rest result^)
                 (== list1 `(,el . ,rest))
                 (conde ((== result `(,el . ,result^))
                         (not-in-listo el list2)
                         (differenceo rest list2 result^))
                        ((membero el list2)
                         (differenceo rest list2 result)))
                 ))))

(define (leto vars cont jexpr)
  (fresh (k v rest let-rest)
         (== vars `((,k . ,v) . ,rest))
         (== jexpr (jlet k v let-rest))
         (conde ((== rest `())
                 (== let-rest cont))
                ((=/= rest `())
                 (leto rest cont let-rest)))))

(define (begino lst jexpr)
  (conde ((== lst `()) (== jexpr (jundef)))
         ((== lst `(,jexpr)))
         ((fresh (a rest rest-exp)
                 (== lst `(,a . ,rest))
                 (=/= rest `())
                 (== jexpr (jbeg a rest-exp))
                 (begino rest rest-exp)
                 ))))

(define (hoist-varo stmt vars)
  (conde ((== vars `())
          (fresh (x) (conde ((== stmt `(return ,x)))
                            ((== stmt `(throw ,x)))
                            ((hoist-var-expo stmt `())))))
         ((fresh (x) (== stmt `(var . ,x)) (hoist-nameso x vars)))
         ((fresh (try-stmt catch-stmt catch-var)
                 (== stmt `(try ,try-stmt catch ,catch-var ,catch-stmt))
                 (hoist-var-listo `(,try-stmt ,catch-stmt) vars)))
         ((fresh (try-stmt catch-stmt finally-stmt catch-var)
                 (== stmt `(try ,try-stmt catch ,catch-var ,catch-stmt finally ,finally-stmt))
                 (hoist-var-listo `(,try-stmt ,catch-stmt ,finally-stmt) vars)))
         ((fresh (cond then else)
                 (== stmt `(if ,cond ,then ,else))
                 (hoist-var-listo `(,then ,else) vars)))
         ((fresh (cond body temp temp^)
                 (== stmt `(while ,cond . ,body))
                 (hoist-var-expo cond temp)
                 (hoist-var-listo body temp^)
                 (appendo temp temp^ vars)))
         ((fresh (exps)
                 (== stmt `(begin . ,exps))
                 (hoist-var-listo exps vars)))
         ((fresh (init cond inc body)
                 (== stmt `(for (,init ,cond ,inc) . ,body))
                 (hoist-var-listo `(,init . ,body) vars)))
         ))

(define (hoist-var-expo stmt vars)
  (fresh (x)
         (== vars `())
         (conde ((== stmt `(number ,x)))
                ((== stmt `(string ,x)))
                ((== stmt `(object . ,x)))
                ((== stmt `(comma . ,x)))
                ((== stmt #t))
                ((== stmt #f))
                ((== stmt (jundef)))
                ((== stmt (jnul)))
                ((symbolo stmt ))
                ((fresh (func args) (== stmt `(call ,func . ,args))))
                ((fresh (erest) (== stmt `(function . ,erest))))
                ((== stmt `(break)))
                ((== stmt `(op . ,x)))
                ((== stmt `(@ . ,x)))
                ((== stmt `(:= . ,x)))))
  )

(define (hoist-var-listo exp-list vars)
  (conde ((== exp-list `()) (== vars `()))
         ((fresh (e erest v vrest)
                 (== exp-list `(,e . ,erest))
                 (hoist-varo e v)
                 (hoist-var-listo erest vrest)
                 (appendo v vrest vars))
          )))

(define (hoist-pairso vars pairs)
  (conde ((== vars `()) (== pairs `()))
         ((fresh (var val name rest v-rest)
                 (== vars `(,var . ,v-rest))
                 (conde ((== var `(,name ,val))
                         (== pairs `((,name ,val) . ,rest)))
                        ((symbolo var)
                         (== pairs rest)))
                 (hoist-pairso v-rest rest)))))

(define (hoist-nameso vars names)
  (conde ((== vars `()) (== names `()))
         ((fresh (var v-rest name val rest)
                 (== vars `(,var . ,v-rest))
                 (== names `(,name . ,rest))
                 (conde ((== var `(,name ,val)))
                        ((symbolo var)
                         (== name var)))
                 (hoist-nameso v-rest rest)))))

(define (pair-assigno pairs jexpr env)
  (fresh (var val val^ rest cont)
         (== pairs `((,var ,val) . ,rest))
         (symbolo var)
         (parse-exp-envo val val^ env)
         (conde ((== rest `())
                 (== jexpr (jassign (jvar var) val^)))
                ((=/= rest `())
                 (== jexpr (jbeg (jassign (jvar var) val^) cont))
                 (pair-assigno rest cont env)
                 ))))

(define (allocato list cont out)
  (conde ((== list `()) (== out cont))
         ((fresh (a rest rest-padded)
                 (== list `(,a . ,rest))
                 (== out (jlet a (jall (jundef)) rest-padded))
                 (allocato rest cont rest-padded)))))

(define (assigno list cont out)
  (conde ((== list `()) (== out cont))
         ((fresh (a b rest -rest rest-padded)
                 (== list `(,a . ,rest))
                 (== out (jlet a (jall (jvar a)) rest-padded))
                 (assigno rest cont rest-padded)))))

(define/match (mknum->num x)
  [((list)) 0]
  [((cons d rest)) (+ d (* 2 (mknum->num rest)))]
  [(_) (begin x)])

(define/match (dehumanize stmt )
  [((? string?)) (jstr stmt )]
  [((? integer?)) (jnum stmt )]
  [((list)) `()]
  [((? list?)) (cons (dehumanize (car stmt )) (dehumanize (cdr stmt )))]
  [(_) stmt ])

(define/match (humanize stmt )
  [((list `string x)) (list->string (map (compose integer->char mknum->num) x))]
  [((list `number x)) (mknum->num x)]
  [((list)) `()]
  [((? list?)) (cons (humanize (car stmt )) (humanize (cdr stmt )))]
  [(_) stmt ])

