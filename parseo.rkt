#lang racket
(require "js-structures.rkt" "faster-miniKanren/mk.rkt" "evalo.rkt" "helpers.rkt")
(provide hoist-varo humanize dehumanize parseo/readable parseo)

; Parse a JavaScript statement with human-readable literals
(define (parseo/readable stmt jexpr)
  (parseo (dehumanize stmt) jexpr))

; Parse a JavaScript statement with relational number and string literals
(define (parseo stmt jexpr)
  (fresh (vars exp^ allocations body)
         (hoist-varo stmt vars)
         (allocato vars body jexpr)
         (parse-envo stmt body vars)))

; Parse a JavaScript statement to LambdaJS expression passing the env
(define (parse-envo stmt jexpr env)
  (conde
    ; expressions have a helper for their own
    ((parse-expr-envo stmt jexpr env))
    ; begin statement (Section 3.2.7)
    ((fresh (stmts jexprs begin-jexpr)
       (== stmt `(begin . ,stmts))
       (== jexpr (jbeg begin-jexpr (jundef)))
       (parse-env-listo stmts jexprs env)
       (begino jexprs begin-jexpr)))
    ; if statement  (Section 3.2.7)
    ((fresh (cond-expr then-stmt else-stmt cond-jexpr then-jexpr else-jexpr)
       (== stmt `(if ,cond-expr ,then-stmt ,else-stmt))
       (== jexpr (jbeg (jif cond-jexpr then-jexpr else-jexpr) (jundef)))
       (parse-expr-envo cond-expr cond-jexpr env)
       (parse-env-listo `(,then-stmt ,else-stmt)
                        `(,then-jexpr ,else-jexpr)
                        env)))
    ; variable declaration (Section 3.2.1)
    ((fresh (vars bindings assignments-jexpr)
       (== stmt `(var . ,vars))
       (hoist-pairso vars bindings)
       (conde ((== bindings `()) (== jexpr (jundef)))
              ((== jexpr (jbeg assignments-jexpr (jundef)))
               (=/= bindings `())
               (pair-assigno bindings assignments-jexpr env)))))
    ; for loops (Section 3.2.7)
    ((fresh (init-stmt init-jexpr
             cond-expr cond-jexpr
             inc-expr inc-jexpr
             body-stmts body-jexprs body-jexpr)
       (== stmt `(for (,init-stmt ,cond-expr ,inc-expr) . ,body-stmts))
       (== jexpr (jbeg init-jexpr
                       (jcatch `break
                               (jwhile cond-jexpr (jbeg body-jexpr inc-jexpr))
                               `e
                               (jundef))))
       (parse-expr-env-listo `(,cond-expr ,inc-expr) `(,cond-jexpr ,inc-jexpr) env)
       (parse-envo init-stmt init-jexpr env)
       (parse-env-listo body-stmts body-jexprs env)
       (begino body-jexprs body-jexpr)))
    ; return control effect (Section 3.2.8)
    ((fresh (val-expr val-jexpr)
       (== stmt `(return ,val-expr))
       (== jexpr (jthrow `return val-jexpr))
       (parse-expr-envo val-expr val-jexpr env)))
    ; throw control effect (Section 3.2.8)
    ((fresh (val-expr val-jexpr)  ;; throw
       (== stmt `(throw ,val-expr))
       (== jexpr (jthrow `error val-jexpr))
       (parse-expr-envo val-expr val-jexpr env)))
    ; break control effect (Section 3.2.8)
    ((== stmt `(break)) (== jexpr (jthrow `break (jundef))))
    ; try/catch control effect (Section 3.2.8)
    ((fresh (try-stmt try-jexpr catch-stmt catch-jexpr catch-var catch-env)
       (== stmt `(try ,try-stmt catch ,catch-var ,catch-stmt))
       (== jexpr
           (jbeg (jcatch `error try-jexpr catch-var
                         (jlet catch-var (jall (jvar catch-var)) catch-jexpr))
                 (jundef)))
       (== catch-env `(,catch-var . ,env))
       (parse-envo try-stmt try-jexpr env)
       (parse-envo catch-stmt catch-jexpr catch-env)))
    ; try/finally control effect (Section 3.2.8)
    ((fresh (try-stmt try-jexpr finally-stmt finally-jexpr)
       (== stmt `(try ,try-stmt finally ,finally-stmt))
       (== jexpr (jfin try-jexpr (jbeg finally-jexpr (jundef))))
       (parse-envo try-stmt try-jexpr env)
       (parse-envo finally-stmt finally-jexpr env)))
    ; try/catch/finally control effect (Section 3.2.8)
    ((fresh (try-stmt try-jexpr
             catch-stmt catch-jexpr catch-var catch-env
             finally-stmt finally-jexpr)
       (== stmt `(try ,try-stmt
                  catch ,catch-var ,catch-stmt
                  finally ,finally-stmt))
       (== jexpr (jbeg (jcatch `error try-jexpr catch-var catch-jexpr)
                       (jbeg finally-jexpr (jundef))))
       (== catch-env `(,catch-var . ,env))
       (parse-envo try-stmt try-jexpr env)
       (parse-envo catch-stmt catch-jexpr catch-env)
       (parse-envo finally-stmt finally-jexpr env)))
    ; while statements (Section 3.2.7)
    ((fresh (cond-expr cond-jexpr body-stmts body-jexprs body-jexpr)
       (== stmt `(while ,cond-expr . ,body-stmts))
       (== jexpr (jcatch `break (jwhile cond-jexpr body-jexpr) `e (jundef)))
       (parse-expr-envo cond-expr cond-jexpr env)
       (parse-env-listo body-stmts body-jexprs env)
       (begino body-jexprs body-jexpr)))))

; Parse a JavaScript expression to LambdaJS expression passing the env
(define (parse-expr-envo expr jexpr env)
  (conde
   ;; variables (Section 3.2.1)
   ((symbolo expr ) (== jexpr (jderef (jvar expr ))))
   ;; simple literals
   ((conde ((== expr jexpr)
            (fresh (x) (conde ((== expr `(number ,x)))
                              ((== expr `(string ,x))))))
           ((== expr #t) (== jexpr (jbool #t)))
           ((== expr #f) (== jexpr (jbool #f)))
           ((== expr (jnul)) (== jexpr (jnul)))
           ((== expr (jundef)) (== jexpr (jundef)))))
   ;; builtin operations (Section 3.2.5)
   ((fresh (rator rands rand-jexprs)
      (== expr `(op ,rator . ,rands))
      (== jexpr (jdelta rator rand-jexprs))
      (parse-expr-env-listo rands rand-jexprs env)))
   ;; assignments (Section 3.2.6) ---------- TODO: debug this
   ((fresh (lhs-expr rhs-expr rhs-jexpr)
      (== expr `(:= ,lhs-expr ,rhs-expr))
      (conde ((symbolo lhs-expr)
              (== jexpr (jassign (jvar lhs-expr) rhs-jexpr))
              (parse-expr-envo rhs-expr rhs-jexpr env))
             ((fresh (obj-expr obj-jexpr obj-var key-expr key-jexpr key-var
                      rhs-var env/obj env/obj+key)
                (== lhs-expr `(@ ,obj-expr ,key-expr))
                (== jexpr
                    (jlet
                      obj-var obj-jexpr
                      (jlet
                        key-var key-jexpr
                        (jlet
                          rhs-var rhs-jexpr
                          (jbeg (jassign
                                  (jvar obj-var)
                                  (jset (jderef (jvar obj-var)) (jstr "public")
                                        (jset (jget (jderef (jvar obj-var))
                                                    (jstr "public"))
                                              (jvar key-var) (jvar rhs-var))))
                                (jvar rhs-var))))))
                (symbolo obj-var)
                (symbolo key-var)
                (symbolo rhs-var)
                (== env/obj     `(,obj-var . ,env))
                (== env/obj+key `(,key-var . ,env/obj))
                (not-in-listo obj-var env)
                (not-in-listo key-var env/obj)
                (not-in-listo rhs-var env/obj+key)
                (parse-expr-envo obj-expr obj-jexpr env)
                (parse-expr-envo key-expr key-jexpr env/obj)
                (parse-expr-envo rhs-expr rhs-jexpr env/obj+key))))))
   ;; object field access (Section 3.2.2)
   ((fresh (obj-expr obj-jexpr field-expr field-jexpr)
      (== expr `(@ ,obj-expr ,field-expr))
      (== jexpr (jget (jget (jderef obj-jexpr) (jstr "public")) field-jexpr))
      (parse-expr-envo obj-expr obj-jexpr env)
      (parse-expr-envo field-expr field-jexpr env)))
   ;; Function call (Section 3.2.4)
   ((fresh (func-expr func-jexpr arg-exprs arg-jexprs)
      (== expr `(call ,func-expr . ,arg-exprs))
      (== jexpr (japp (jget (jget (jderef func-jexpr) (jstr "private"))
                            (jstr "call"))
                      arg-jexprs))
      (parse-expr-envo func-expr func-jexpr env)
      (parse-expr-env-listo arg-exprs arg-jexprs env)))
   ;; object creation (Section 3.2.4)
   ((fresh (field-bindings public-jexpr)
         (== expr `(object . ,field-bindings))
         (== jexpr (jall (jset (jobj (list (cons (jstr "private") (jobj `()))))
                               (jstr "public")
                               public-jexpr)))
         (parse-obj-bindingso field-bindings public-jexpr env)))
   ;; object definition (Section 3.2.4)
   ((functiono expr jexpr env))
   ;; Comma expression sequencing
   ((fresh (exps exps^)
           (== expr `(comma . ,exps))
           (parse-expr-env-listo exps exps^ env)
           (begino exps^ jexpr)))))

(define (parse-env-listo lst jlst env)
  (conde ((== lst `()) (== jlst `()))
         ((fresh (p p^ rest rest^)
                 (== lst `(,p . ,rest))
                 (== jlst `(,p^ . ,rest^))
                 (parse-envo p p^ env)
                 (parse-env-listo rest rest^ env)
                 ))))

(define (parse-expr-env-listo lst jlst env)
  (conde ((== lst `()) (== jlst `()))
         ((fresh (p p^ rest rest^)
                 (== lst `(,p . ,rest))
                 (== jlst `(,p^ . ,rest^))
                 (parse-expr-envo p p^ env)
                 (parse-expr-env-listo rest rest^ env)
                 ))))


(define (lh-parseo stmt jexpr env)
  (conde ((symbolo stmt ) (== jexpr (jvar stmt )))
         ((fresh (obj obj^ val val^)
                 (== stmt `(@ ,obj ,val))
                 (== jexpr (jget (jget obj^ (jstr "public")) val^))
                 (parse-expr-env-listo `(,obj ,val) `(,obj^ ,val^) env)))))

(define (parse-obj-bindingso field-bindings obj-jexpr env)
  (conde ((== field-bindings `())
          (== obj-jexpr (jobj `())))
         ((fresh (field val-expr val-jexpr rest-bindings prev-obj-jexpr)
            (== field-bindings `((,field ,val-expr) . ,rest-bindings))
            (== obj-jexpr (jset prev-obj-jexpr field val-jexpr))
            (parse-expr-envo val-expr val-jexpr env)
            (parse-obj-bindingso rest-bindings prev-obj-jexpr env)))))

(define (functiono stmt jexpr env)
  (fresh (params body body^ body^^ body^^^ body^^^^ vars vars^ payload env^ env^^ return-var)
         (== stmt `(function ,params . ,body))
         (== jexpr (jall (jset (jobj `((,(jstr "public") . ,(jobj `()))))
                              (jstr "private")
                              (jset (jobj `()) (jstr "call")
                                    (jfun params
                                          (jcatch `return (jbeg body^^^^ (jundef))
                                                  'result (jvar 'result)))))))
         (hoist-var-listo body vars)
         (differenceo vars params vars^)
         (appendo vars^ env env^)
         (appendo params env^ env^^)
         (parse-env-listo body body^ env^^)
         (begino body^ body^^)
         (allocato vars^ body^^ body^^^)
         (assigno params body^^^ body^^^^)
         ))

(define (differenceo list1 list2 result)
  (conde ((== list1 `())
          (== result list1))
         ((fresh (el rest result^)
                 (== list1 `(,el . ,rest))
                 (conde ((== result `(,el . ,result^))
                         (not-in-listo el list2)
                         (differenceo rest list2 result^))
                        ((membero el list2)
                         (differenceo rest list2 result)))
                 ))))

(define (leto vars cont jexpr)
  (fresh (k v rest let-rest)
         (== vars `((,k . ,v) . ,rest))
         (== jexpr (jlet k v let-rest))
         (conde ((== rest `())
                 (== let-rest cont))
                ((=/= rest `())
                 (leto rest cont let-rest)))))

(define (begino lst jexpr)
  (conde ((== lst `()) (== jexpr (jundef)))
         ((== lst `(,jexpr)))
         ((fresh (a rest rest-exp)
                 (== lst `(,a . ,rest))
                 (=/= rest `())
                 (== jexpr (jbeg a rest-exp))
                 (begino rest rest-exp)
                 ))))

(define (hoist-varo stmt vars)
  (conde ((== vars `())
          (fresh (x) (conde ((== stmt `(return ,x)))
                            ((== stmt `(throw ,x)))
                            ((hoist-var-expo stmt `())))))
         ((fresh (x) (== stmt `(var . ,x)) (hoist-nameso x vars)))
         ((fresh (try-stmt catch-stmt catch-var)
                 (== stmt `(try ,try-stmt catch ,catch-var ,catch-stmt))
                 (hoist-var-listo `(,try-stmt ,catch-stmt) vars)))
         ((fresh (try-stmt catch-stmt finally-stmt catch-var)
                 (== stmt `(try ,try-stmt catch ,catch-var ,catch-stmt finally ,finally-stmt))
                 (hoist-var-listo `(,try-stmt ,catch-stmt ,finally-stmt) vars)))
         ((fresh (cond then else)
                 (== stmt `(if ,cond ,then ,else))
                 (hoist-var-listo `(,then ,else) vars)))
         ((fresh (cond body temp temp^)
                 (== stmt `(while ,cond . ,body))
                 (hoist-var-expo cond temp)
                 (hoist-var-listo body temp^)
                 (appendo temp temp^ vars)))
         ((fresh (exps)
                 (== stmt `(begin . ,exps))
                 (hoist-var-listo exps vars)))
         ((fresh (init cond inc body)
                 (== stmt `(for (,init ,cond ,inc) . ,body))
                 (hoist-var-listo `(,init . ,body) vars)))
         ))

(define (hoist-var-expo stmt vars)
  (fresh (x)
         (== vars `())
         (conde ((== stmt `(number ,x)))
                ((== stmt `(string ,x)))
                ((== stmt `(object . ,x)))
                ((== stmt `(comma . ,x)))
                ((== stmt #t))
                ((== stmt #f))
                ((== stmt (jundef)))
                ((== stmt (jnul)))
                ((symbolo stmt ))
                ((fresh (func args) (== stmt `(call ,func . ,args))))
                ((fresh (erest) (== stmt `(function . ,erest))))
                ((== stmt `(break)))
                ((== stmt `(op . ,x)))
                ((== stmt `(@ . ,x)))
                ((== stmt `(:= . ,x)))))
  )

(define (hoist-var-listo exp-list vars)
  (conde ((== exp-list `()) (== vars `()))
         ((fresh (e erest v vrest)
                 (== exp-list `(,e . ,erest))
                 (hoist-varo e v)
                 (hoist-var-listo erest vrest)
                 (appendo v vrest vars))
          )))

(define (hoist-pairso vars pairs)
  (conde ((== vars `()) (== pairs `()))
         ((fresh (var val name rest v-rest)
                 (== vars `(,var . ,v-rest))
                 (conde ((== var `(,name ,val))
                         (== pairs `((,name ,val) . ,rest)))
                        ((symbolo var)
                         (== pairs rest)))
                 (hoist-pairso v-rest rest)))))

(define (hoist-nameso vars names)
  (conde ((== vars `()) (== names `()))
         ((fresh (var v-rest name val rest)
                 (== vars `(,var . ,v-rest))
                 (== names `(,name . ,rest))
                 (conde ((== var `(,name ,val)))
                        ((symbolo var)
                         (== name var)))
                 (hoist-nameso v-rest rest)))))

(define (pair-assigno pairs jexpr env)
  (fresh (var val val^ rest cont)
         (== pairs `((,var ,val) . ,rest))
         (symbolo var)
         (parse-expr-envo val val^ env)
         (conde ((== rest `())
                 (== jexpr (jassign (jvar var) val^)))
                ((=/= rest `())
                 (== jexpr (jbeg (jassign (jvar var) val^) cont))
                 (pair-assigno rest cont env)
                 ))))

(define (allocato list cont out)
  (conde ((== list `()) (== out cont))
         ((fresh (a rest rest-padded)
                 (== list `(,a . ,rest))
                 (== out (jlet a (jall (jundef)) rest-padded))
                 (allocato rest cont rest-padded)))))

(define (assigno list cont out)
  (conde ((== list `()) (== out cont))
         ((fresh (a b rest -rest rest-padded)
                 (== list `(,a . ,rest))
                 (== out (jlet a (jall (jvar a)) rest-padded))
                 (assigno rest cont rest-padded)))))

(define/match (mknum->num x)
  [((list)) 0]
  [((cons d rest)) (+ d (* 2 (mknum->num rest)))]
  [(_) (begin x)])

(define/match (dehumanize stmt )
  [((? string?)) (jstr stmt )]
  [((? integer?)) (jnum stmt )]
  [((list)) `()]
  [((? list?)) (cons (dehumanize (car stmt )) (dehumanize (cdr stmt )))]
  [(_) stmt ])

(define/match (humanize stmt )
  [((list `string x)) (list->string (map (compose integer->char mknum->num) x))]
  [((list `number x)) (mknum->num x)]
  [((list)) `()]
  [((? list?)) (cons (humanize (car stmt )) (humanize (cdr stmt )))]
  [(_) stmt ])

