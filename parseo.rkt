#lang racket
(require "js-structures.rkt" "faster-miniKanren/mk.rkt" "evalo.rkt")
(provide pull-varo pull-varo-list pull-pairso pull-names-listo humanize dehumanize parseo parseo-h parseo-nh)

(define (parseo exp jexp)
  (conde ((parse-expo exp jexp)) ;; Expressions
         ((fresh (exps exps^) ;; Begin
                 (== exp `(begin . ,exps))
                 (parse-listo exps exps^)
                 (begino exps^ jexp)))
         ((fresh (cond then else cond^ then^ else^) ;; if statements
                 (== exp `(if ,cond ,then ,else))
                 (parse-expo cond cond^)
                 (parse-listo `(,then ,else) `(,then^ ,else^))
                 (== jexp (jif cond^ then^ else^))))
         ;; different breaks
         ((fresh (val val^)  ;; return
                 (== exp `(return ,val))
                 (parse-expo val val^)
                 (== jexp (jthrow `return val^))))
         ((fresh (val val^)  ;; throw
                 (== exp `(throw ,val))
                 (parse-expo val val^)
                 (== jexp (jthrow `error val^))))
         ((fresh (val)  ;; break
                 (== exp  `(break))
                 (== jexp (jthrow `break (jundef)))))
         ((fresh (try-exp catch-exp try-exp^ catch-exp^ label) ;; Try/catch
                 (== exp `(try ,try-exp catch ,label ,catch-exp))
                 (parse-listo `(,try-exp ,catch-exp) `(,try-exp^ ,catch-exp^))
                 (== jexp (jcatch `error try-exp^ label
                                  (jlet label (jall (jvar label)) catch-exp^)))))
         ((fresh (try-exp try-exp^  finally-exp finally-exp^) ;; Try/finally
                 (== exp `(try ,try-exp finally ,finally-exp))
                 (parse-listo `(,try-exp ,finally-exp) `(,try-exp^ ,finally-exp^))
                 (== jexp (jfin try-exp^ finally-exp^))))
         ((fresh (try-exp catch-exp try-exp^ catch-exp^ finally-exp finally-exp^ label) ;; Try/catch/finally
                 (== exp `(try ,try-exp catch ,label ,catch-exp finally ,finally-exp))
                 (parse-listo `(,try-exp ,catch-exp ,finally-exp) `(,try-exp^ ,catch-exp^ ,finally-exp^))
                 (== jexp (jbeg (jcatch `error try-exp^ label catch-exp^) finally-exp^)))) ;; QUESTIONABLE!
         ((fresh (cond body cond^ body^ body^^) ;; while statements
                 (== exp `(while ,cond . ,body))
                 (parse-expo cond cond^)
                 (parse-listo body body^)
                 (begino body^ body^^)
                 (== jexp (jcatch `break (jwhile cond^ body^^) `e (jundef)))))
         ((parse-foro exp jexp))
         ((switcho exp jexp))
         ((varo exp jexp)) ;; Var
         ))

(define (parse-expo exp jexp)
  (conde ;; primitive values
    ((== exp jexp)(fresh (x) (conde ((== exp `(number ,x)))
                                    ((== exp `(string ,x))))))
    ((== exp #t) (== jexp (jbool #t)))
    ((== exp #f) (== jexp (jbool #f)))
    ((symbolo exp) (== jexp (jderef (jvar exp))))
    ((== exp (jundef)) (== jexp (jundef)))
    ((== exp (jnul)) (== jexp (jnul)))
    ((objecto exp jexp))
    ((fresh (op vals vals^) ;; Basic operations
            (== exp `(op ,op . ,vals))
            (parse-exp-listo vals vals^)
            (== jexp (jdelta op vals^))))
    ((functiono exp jexp)) ;; Functions
    ((fresh (func args func^ args^) ;; Function call
            (== exp `(call ,func . ,args))
            (parse-exp-listo `(,func . ,args) `(,func^ . ,args^))
            (== jexp (jcatch `return (japp func^ args^) `result (jvar `result)))))
    ((fresh (val val^ index index^) ;; Field getter
            (== exp `(@ ,val ,index))
            (parse-exp-listo `(,val ,index) `(,val^ ,index^))
            (== jexp (jderef (jget val^ index^)))))
    ((fresh (var val var^ val^) ;; Assignment
            (== exp `(:= ,var ,val))
            (lh-parseo var var^)
            (parse-expo val val^)
            (== jexp (jassign var^ val^))))
    ))

(define (parse-foro exp jexp)
  (fresh (init init^ cond cond^ inc inc^ body body^ body^^)
         (== exp `(for (,init ,cond ,inc) . ,body))
         (parse-expo cond cond^)
         (parse-listo `(,inc . (,init . ,body)) `(,inc^ . (,init^ . ,body^)))
         (begino body^ body^^)
         (== jexp (jbeg init^ (jcatch `break (jwhile cond^ (jbeg body^^ inc^)) `e (jundef))))))

(define (parse-listo lst jlst)
  (conde ((== lst `()) (== jlst `()))
         ((fresh (p p^ rest rest^)
                 (== lst `(,p . ,rest))
                 (parseo p p^)
                 (parse-listo rest rest^)
                 (== jlst `(,p^ . ,rest^))))))

(define (parse-exp-listo lst jlst)
  (conde ((== lst `()) (== jlst `()))
         ((fresh (p p^ rest rest^)
                 (== lst `(,p . ,rest))
                 (parse-expo p p^)
                 (parse-exp-listo rest rest^)
                 (== jlst `(,p^ . ,rest^))))))

(define (parseo-h exp jexp)
  (let ([exp (dehumanize exp)])
    (fresh (vars exp^ allocations body)
           (pull-names-listo `(,exp) vars)
           (allocato vars body jexp)
           (parseo exp body))))

(define (parseo-nh exp jexp)
  (fresh (vars exp^ allocations body)
         (pull-names-listo `(,exp) vars)
         (allocato vars body jexp)
         (parseo exp body)))

(define (lh-parseo exp jexp)
  (conde ((symbolo exp) (== jexp (jvar exp)))
         ((fresh (obj val)
                 (== exp `(@ ,obj ,val))
                 (== jexp (jbeg (jset obj val (jall (jundef))) (jget obj val))))))) ;; inefficient! TODO: fix


(define (objecto exp jexp)
  (fresh (pairs binds)
         (== exp `(object . ,pairs))
         (object-helpero pairs binds)
         (== jexp (jobj (list (cons (jstr "private") (jobj `())) (cons (jstr "public") (jobj binds)))))))

(define (object-helpero exp-binds binds)
  (conde ((== exp-binds `()) (== binds `()))
         ((fresh (key value rest pair-rest)
                 (== exp-binds `((,key ,value) . ,rest))
                 (== binds `((,key . ,value)  . ,pair-rest))
                 (object-helpero rest pair-rest)))))

(define (varo exp jexp)
  (fresh (vars pairs jexp^)
         (== exp `(var . ,vars))
         (pull-pairso vars pairs)
         (conde ((== pairs `()) (== jexp (jundef)))
                ((=/= pairs `()) (pair-assigno pairs jexp^) (== jexp (jbeg jexp^ (jundef)))))))

(define (functiono exp jexp)
  (fresh (params body body^ body^^ body^^^ vars vars^)
         (== exp `(function ,params . ,body))
         (parse-listo body body^)
         (begino body^ body^^)
         (pull-names-listo body vars) ;; TODO: No effect
         (assigno params body^^ body^^^)
         (== jexp (jfun params body^^^))))

(define (leto vars cont jexp)
  (fresh (k v rest let-rest)
         (== vars `((,k . ,v) . ,rest))
         (== jexp (jlet k v let-rest))
         (conde ((== rest `())
                 (== let-rest cont))
                ((=/= rest `())
                 (leto rest cont let-rest)))))

(define (begino lst jexp)
  (conde ((== lst `()) (== jexp (jundef)))
         ((== lst `(,jexp)))
         ((fresh (a rest rest-exp)
                 (== lst `(,a . ,rest))
                 (=/= rest `())
                 (begino rest rest-exp)
                 (== jexp (jbeg a rest-exp))))))

(define (switcho exp jexp)
  (fresh (pairs val val^)
         (== exp `(switch ,val . ,pairs))
         (parse-expo val val^)
         (switch-helpero pairs val^ jexp)))

(define (switch-helpero pairs val jexp)
  (conde ((== pairs `())
          (== jexp (jundef)))
         ((fresh (target body target^ body^ rest rest-exp)
                 (== pairs `((,target ,body) . ,rest))
                 (parse-expo target target^)
                 (parseo body body^)
                 (switch-helpero rest val rest-exp)
                 (== jexp (jif (jdelta `=== `(,val ,target^)) body^ rest-exp))))))

(define (pull-varo exp vars)
  (conde ((pull-var-expo exp vars))
         ((== exp `(var . ,vars)))
         ((fresh (x) (== exp `(return ,x))) (== vars `()))
         ((fresh (x) (== exp `(throw ,x))) (== vars `()))
         ((fresh (try-exp catch-exp label)
                 (== exp `(try ,try-exp catch ,label ,catch-exp))
                 (pull-varo-list `(,try-exp ,catch-exp) vars)))
         ((fresh (try-exp catch-exp finally-exp label)
                 (== exp `(try ,try-exp catch ,label ,catch-exp finally ,finally-exp))
                 (pull-varo-list `(,try-exp ,catch-exp ,finally-exp) vars)))
         ((fresh (cond then else)
                 (== exp `(if ,cond ,then ,else))
                 (pull-varo-list `(,then ,else) vars)))
         ((fresh (cond body temp temp^)
                 (== exp `(while ,cond . ,body))
                 (pull-var-expo cond temp)
                 (pull-varo-list body temp^)
                 (appendo temp temp^ vars)))
         ((fresh (t x)
                 (== exp `(switch ,t . ,x))
                 (pull-var-switcho x vars)))
         ((fresh (exps)
                 (== exp `(begin . ,exps))
                 (pull-varo-list exps vars)))
         ((fresh (init cond inc body)
                 (== exp `(for (,init ,cond ,inc) . ,body))
                 (pull-varo-list `(,init . ,body) vars)))
         ))

(define (pull-var-switcho switch vars)
  (conde ((== switch `()) (== vars `()))
         ((fresh (case code rest v v2)
                 (== switch `((,case ,code) . ,rest))
                 (pull-varo code v)
                 (appendo v v2 vars)
                 (pull-var-switcho rest v2)))))

(define (pull-var-expo exp vars)
  (conde ((== vars `())
          (conde ((fresh (x) (== exp `(number ,x))))
                 ((fresh (x) (== exp `(string ,x))))
                 ((fresh (x) (== exp `(object . ,x))))
                 ((== exp #t))
                 ((== exp #f))
                 ((== exp (jundef)))
                 ((== exp (jnul)))
                 ((symbolo exp))
                 ((fresh (erest) (== exp `(function . ,erest))))
                 ((== exp `(break)))
                 ((fresh (x) (== exp `(op . ,x))))
                 ((fresh (x) (== exp `(@ . ,x))))
                 ((fresh (x) (== exp `(:= . ,x))))
                 ))
         ((fresh (func args)
                 (== exp `(call ,func . ,args))
                 (pull-var-exp-listo args vars)))
         ))

(define (pull-varo-list exp-list vars)
  (conde ((== `(,exp-list . ,vars) `(() . ())))
         ((fresh (e erest v vrest)
                 (== exp-list `(,e . ,erest))
                 (pull-varo e v)
                 (pull-varo-list erest vrest)
                 (appendo v vrest vars))
          )))

(define (pull-var-exp-listo exp-list vars)
  (conde ((== `(,exp-list . ,vars) `(() . ())))
         ((fresh (e erest v vrest)
                 (== exp-list `(,e . ,erest))
                 (pull-var-expo e v)
                 (pull-var-exp-listo erest vrest)
                 (appendo v vrest vars))
          )))

(define (pull-pairso vars pairs)
  (conde ((== `(,vars . ,pairs) `(() . ())))
         ((fresh (var val name rest v-rest)
                 (== vars `(,var . ,v-rest))
                 (conde ((== var `(,name ,val))
                         (== pairs `((,name ,val) . ,rest)))
                        ((symbolo var)
                         (== pairs rest)))
                 (pull-pairso v-rest rest)))))

(define (pull-nameso vars names)
  (conde ((== `(,vars . ,names) `(() . ())))
         ((fresh (var v-rest name val rest)
                 (== vars `(,var . ,v-rest))
                 (== names `(,name . ,rest))
                 (conde ((== var `(,name ,val)))
                        ((symbolo var)
                         (== name var)))
                 (pull-nameso v-rest rest)))))

(define (pull-names-listo exp names)
  (fresh (vars)
         (pull-varo-list exp vars)
         (pull-nameso vars names)))

(define (pair-assigno pairs jexp)
  (fresh (var val var^ val^ rest jexp^ )
         (== pairs `((,var ,val) . ,rest))
         (lh-parseo var var^)
         (parse-expo val val^)
         (conde ((== rest `())
                 (== jexp (jassign var^ val^)))
                ((=/= rest `())
                 (pair-assigno rest jexp^)
                 (== jexp (jbeg (jassign var^ val^) jexp^))))))

(define (allocato list cont out)
  (conde ((== `(,list . ,out) `(() . ,cont)))
         ((fresh (a rest rest-padded)
                 (== list `(,a . ,rest))
                 (== out (jlet a (jall (jundef)) rest-padded))
                 (allocato rest cont rest-padded)))))

(define (assigno list cont out)
  (conde ((== `(,list . ,out) `(() . ,cont)))
         ((fresh (a b rest -rest rest-padded)
                 (== list `(,a . ,rest))
                 (== out (jlet a (jall (jvar a)) rest-padded))
                 (assigno rest cont rest-padded)))))

(define/match (mknum->num x)
  [((list)) 0]
  [((cons d rest)) (+ d (* 2 (mknum->num rest)))]
  [(_) (begin x)])

(define/match (dehumanize exp)
  [((? string?)) (jstr exp)]
  [((? integer?)) (jnum exp)]
  [((? list?)) (map dehumanize exp)]
  [(_) exp])

(define/match (humanize exp)
  [((list `string x)) (list->string (map (compose integer->char mknum->num) x))]
  [((list `number x)) (mknum->num x)]
  [((? list?)) (map humanize exp)]
  [(_) exp])

