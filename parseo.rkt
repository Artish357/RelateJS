#lang racket
(require "js-structures.rkt" "faster-miniKanren/mk.rkt" "evalo.rkt")
(provide pull-varo pull-varo-list pull-pairso pull-varo-pairs humanize dehumanize)

(define (parseo exp jexp)
  (conde ((symbolo exp) (== jexp (jvar exp)))
         ((fresh (val index)
                 (== exp `(@ ,val ,index))
                 (== jexp (jget val index))))
         ((fresh (var val)
                 (== exp `(:= ,var ,val))
                 (== jexp (jassign var val))))
         ((functiono exp jexp))
         ((fresh (var val)
                 (== exp `(var ,var))
                 (== jexp (jassign var `undefined))))
         ))

(define (parseo-list lst jlst)
  (fresh (p p^ rest rest^)
         (conde ((== lst `()) (== jlst `()))
                ((== lst `(,p . ,rest))
                 (parseo p p^)
                 (parseo-list rest rest^)
                 (== jlst `(,p^ . ,rest^))))))

(define (parseo-h exp jexp)
  (parseo (dehumanize exp) jexp))

(define (functiono exp jexp)
  (fresh (params body body^ body^^ body^^^ vars vars^)
         (== exp `(function ,params . ,body))
         (parseo-list body body^)
         (begino body^ body^^)
         (pull-varo body^^ vars)
         (pado vars `undefined vars^)
         (conde ((== vars^ `())  (== body^^^ body^^))
                ((=/= vars^ `())
                 (leto vars^ body^^ body^^^)
                 ))
         (== jexp (jfun params body^^^))
         ))

(define (leto vars cont jexp)
  (fresh (k v rest jexp-rest)
         (== vars `((,k . ,v) . ,rest))
         (conde ((== rest `())
                 (== jexp (jlet k v cont)))
                ((=/= rest `())
                 (leto rest cont jexp-rest)
                 (== jexp (jlet k v jexp-rest))))))

(define (begino lst jexp)
  (conde ((== lst `()) (== jexp `()))
         ((fresh (e rest rest^)
                 (== lst `(,e . ,rest))
                 (conde ((== rest `()) (== jexp e))
                        ((=/= rest `()) 
                         (begino rest rest^)
                         (== jexp (jbeg e rest^))))))))

(define (pull-varo exp vars)
  (fresh (e erest)
         (conde ((== `(,exp . ,vars) `(() . ())))
                ((== exp `(function . ,erest)) (== vars `()))
                ((symbolo exp) (== vars `()))
                ((== exp `(var . ,vars)))
                ((== exp `(,e . ,erest))
                 (=/= e `var)
                 (pull-varo-list erest vars))
                )
         ))


(define (pull-varo-list exp-list vars)
  (fresh (e erest v vrest)
         (conde ((== `(,exp-list . ,vars) `(() . ())))
                ((== exp-list `(,e . ,erest))
                 (pull-varo e v)
                 (pull-varo-list erest vrest)
                 (extendo v vrest vars))
                )))

(define (pull-pairso vars pairs)
  (conde ((== `(,vars . ,pairs) `(() . ())))
         ((fresh (var val name rest v-rest)
                 (== vars `(,var . ,v-rest))
                 (conde ((== var `(,name ,val)))
                        ((symbolo var)
                         (== `(,name . ,val) `(,var . undefined))))
                 (pull-pairso v-rest rest)
                 (== pairs `((,name . ,val) . ,rest))))))

(define (pull-varo-pairs exp pairs)
  (fresh (vars)
         (pull-varo exp vars)
         (pull-pairso vars pairs)))

(define (pado list el out)
  (fresh (a b rest rest-padded)
         (conde ((== `(,list . ,out) `(() . ())))
                ((== list `(,a . ,rest))
                 (== out `((,a . ,el) . ,rest-padded))
                 (pado rest el rest-padded)))))

(define/match (mknum->num x)
  [((list)) 0]
  [((cons d rest)) (+ d (* 2 (mknum->num rest)))])

(define/match (dehumanize exp)
  [((? string?)) (jstr exp)]
  [((? integer?)) (jnum exp)]
  [((? list?)) (map dehumanize exp)]
  [(_) exp])

(define/match (humanize exp)
  [((list `string x)) (list->string (map (compose integer->char mknum->num) x))]
  [((list `number x)) (mknum->num x)]
  [((? list?)) (map humanize exp)]
  [(_) exp])
