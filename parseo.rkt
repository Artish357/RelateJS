#lang racket
(require "js-structures.rkt" "faster-miniKanren/mk.rkt" "evalo.rkt" "helpers.rkt")
(provide hoist-varo hoist-var-listo hoist-pairso humanize dehumanize parseo/readable parseo)

; Parse JavaScript statements with human-readable literals
(define (parseo/readable stmt ljsexpr)
  (parseo (dehumanize stmt) ljsexpr))

; Parse JavaScript statements with relational number and string literals
(define (parseo stmt jexp)
  (fresh (vars exp^ allocations body)
         (hoist-varo stmt vars)
         (allocato vars body jexp)
         (parse-envo stmt body vars)))

(define (parse-envo stmt jexp env)
  (conde ((parse-exp-envo stmt jexp env)) ;; Expressions
         ((fresh (exps exps^ jexp^) ;; Begin
                 (== stmt `(begin . ,exps))
                 (== jexp (jbeg jexp^ (jundef)))
                 (parse-env-listo exps exps^ env)
                 (begino exps^ jexp^)))
         ((fresh (cond then else cond^ then^ else^) ;; if statements
                 (== stmt `(if ,cond ,then ,else))
                 (== jexp (jbeg (jif cond^ then^ else^) (jundef)))
                 (parse-exp-envo cond cond^ env)
                 (parse-env-listo `(,then ,else) `(,then^ ,else^) env)))
         ((varo stmt jexp env)) ;; Var
         ((parse-foro stmt jexp env))
         ;; different breaks
         ((fresh (val val^)  ;; return
                 (== stmt `(return ,val))
                 (== jexp (jthrow `return val^))
                 (parse-exp-envo val val^ env)
                 ))
         ((fresh (val val^)  ;; throw
                 (== stmt `(throw ,val))
                 (== jexp (jthrow `error val^))
                 (parse-exp-envo val val^ env)
                 ))
         ((fresh (val)  ;; break
                 (== stmt `(break))
                 (== jexp (jthrow `break (jundef)))))
         ((fresh (try-exp catch-exp try-exp^ catch-exp^ catch-var env^) ;; Try/catch
                 (== stmt `(try ,try-exp catch ,catch-var ,catch-exp))
                 (== jexp (jbeg (jcatch `error try-exp^ catch-var
                                  (jlet catch-var (jall (jvar catch-var)) catch-exp^)) (jundef)))
                 (== env^ `(,catch-var . ,env))
                 (parse-env-listo `(,try-exp ,catch-exp) `(,try-exp^ ,catch-exp^) env^)))
         ((fresh (try-exp try-exp^  finally-exp finally-exp^) ;; Try/finally
                 (== stmt `(try ,try-exp finally ,finally-exp))
                 (== jexp (jfin try-exp^ (jbeg finally-exp^ (jundef))))
                 (parse-env-listo `(,try-exp ,finally-exp) `(,try-exp^ ,finally-exp^) env)
                 ))
         ((fresh (try-exp catch-exp try-exp^ catch-exp^ finally-exp finally-exp^ catch-var env^) ;; Try/catch/finally
                 (== stmt `(try ,try-exp catch ,catch-var ,catch-exp finally ,finally-exp))
                 (== jexp (jbeg (jcatch `error try-exp^ catch-var catch-exp^) (jbeg finally-exp^ (jundef))))
                 (== env^ `(,catch-var . ,env))
                 (parse-env-listo `(,try-exp ,catch-exp ,finally-exp) `(,try-exp^ ,catch-exp^ ,finally-exp^) env^)))
         ((fresh (cond body cond^ body^ body^^) ;; while statements
                 (== stmt `(while ,cond . ,body))
                 (== jexp (jcatch `break (jwhile cond^ body^^) `e (jundef)))
                 (parse-exp-envo cond cond^ env)
                 (parse-env-listo body body^ env)
                 (begino body^ body^^)))))

(define (parse-exp-envo stmt jexp env)
  (conde
   ;; Variables
   ((symbolo stmt ) (== jexp (jderef (jvar stmt ))))
   ;; Simple literals
   ((conde ((== stmt jexp) (fresh (x) (conde ((== stmt `(number ,x)))
                                            ((== stmt `(string ,x))))))
           ((== stmt #t) (== jexp (jbool #t)))
           ((== stmt #f) (== jexp (jbool #f)))
           ((== stmt (jnul)) (== jexp (jnul)))
           ((== stmt (jundef)) (== jexp (jundef)))))
   ;; Primitive operations
   ((fresh (op vals vals^)
           (== stmt `(op ,op . ,vals))
           (== jexp (jdelta op vals^))
           (parse-exp-env-listo vals vals^ env)))
   ;; Assignment
   ((fresh (var val var^ val^)
           (== stmt `(:= ,var ,val))
           (conde ((symbolo var) (== jexp (jassign (jvar var) val^)))
                  ((fresh (obj obj^ key key^ obj-parsed temp-var)
                          (== var `(@ ,obj ,key))
                          (== obj-parsed (jvar obj))
                          (symbolo temp-var)
                          (not-in-listo temp-var env)
                          (== jexp (jbeg
                                    (jlet
                                     temp-var
                                     (jset (jderef obj^) (jstr "public") (jset (jget (jderef obj^) (jstr "public")) key^ val^))
                                     (jassign obj^ (jvar temp-var)))
                                    val^))
                          (parse-exp-env-listo `(,key ,obj) `(,key^ ,obj^) env))))
           (parse-exp-envo val val^ env)))
   ;; Field access
   ((fresh (val val^ index index^)
           (== stmt `(@ ,val ,index))
           (== jexp (jget (jget (jderef val^) (jstr "public")) index^))
           (parse-exp-env-listo `(,val ,index) `(,val^ ,index^) env)))
   ;; Function call
   ((fresh (func args func^ args^)
           (== stmt `(call ,func . ,args))
           (== jexp (japp (jget (jget (jderef func^) (jstr "private")) (jstr "call")) args^))
           (parse-exp-env-listo `(,func . ,args) `(,func^ . ,args^) env)))
   ((objecto stmt jexp env))
   ((functiono stmt jexp env))
   ;; Comma expression sequencing
   ((fresh (exps exps^)
           (== stmt `(comma . ,exps))
           (parse-exp-env-listo exps exps^ env)
           (begino exps^ jexp)))))

(define (parse-foro stmt jexp env)
  (fresh (init init^ cond cond^ inc inc^ body body^ body^^)
         (== stmt `(for (,init ,cond ,inc) . ,body))
         (== jexp (jbeg init^ (jcatch `break (jwhile cond^ (jbeg body^^ inc^)) `e (jundef))))
         (parse-exp-env-listo `(,cond ,inc) `(,cond^ ,inc^) env)
         (parse-envo init init^ env)
         (parse-env-listo body body^ env)
         (begino body^ body^^)
         ))

(define (parse-env-listo lst jlst env)
  (conde ((== lst `()) (== jlst `()))
         ((fresh (p p^ rest rest^)
                 (== lst `(,p . ,rest))
                 (== jlst `(,p^ . ,rest^))
                 (parse-envo p p^ env)
                 (parse-env-listo rest rest^ env)
                 ))))

(define (parse-exp-env-listo lst jlst env)
  (conde ((== lst `()) (== jlst `()))
         ((fresh (p p^ rest rest^)
                 (== lst `(,p . ,rest))
                 (== jlst `(,p^ . ,rest^))
                 (parse-exp-envo p p^ env)
                 (parse-exp-env-listo rest rest^ env)
                 ))))


(define (lh-parseo stmt jexp env)
  (conde ((symbolo stmt ) (== jexp (jvar stmt )))
         ((fresh (obj obj^ val val^)
                 (== stmt `(@ ,obj ,val))
                 (== jexp (jget (jget obj^ (jstr "public")) val^))
                 (parse-exp-env-listo `(,obj ,val) `(,obj^ ,val^) env)))))

(define (objecto stmt jexp env)
  (fresh (pairs public)
         (== stmt `(object . ,pairs))
         (== jexp (jall (jset (jobj (list (cons (jstr "private") (jobj `())))) (jstr "public") public)))
         (object-helpero pairs public env)
         ))

(define (object-helpero exp-binds jexp env)
  (conde ((== exp-binds `()) (== jexp (jobj `())))
         ((fresh (key val key^ val^ rest prev curr)
                 (== exp-binds `((,key ,val) . ,rest))
                 (== jexp (jset prev key^ val^))
                 (parse-exp-env-listo `(,key ,val) `(,key^ ,val^) env)
                 (object-helpero rest prev env)))))

(define (varo stmt jexp env)
  (fresh (vars pairs jexp^)
         (== stmt `(var . ,vars))
         (hoist-pairso vars pairs)
         (conde ((== pairs `()) (== jexp (jundef)))
                ((== jexp (jbeg jexp^ (jundef)))
                 (=/= pairs `())
                 (pair-assigno pairs jexp^ env)
                 ))))

(define (functiono stmt jexp env)
  (fresh (params body body^ body^^ body^^^ body^^^^ vars vars^ payload env^ env^^ return-var)
         (== stmt `(function ,params . ,body))
         (== jexp (jall (jset (jobj `((,(jstr "public") . ,(jobj `()))))
                              (jstr "private")
                              (jset (jobj `()) (jstr "call")
                                    (jfun params
                                          (jcatch `return (jbeg body^^^^ (jundef))
                                                  'result (jvar 'result)))))))
         (hoist-var-listo body vars)
         (differenceo vars params vars^)
         (appendo vars^ env env^)
         (appendo params env^ env^^)
         (parse-env-listo body body^ env^^)
         (begino body^ body^^)
         (allocato vars^ body^^ body^^^)
         (assigno params body^^^ body^^^^)
         ))

(define (differenceo list1 list2 result)
  (conde ((== list1 `())
          (== result list1))
         ((fresh (el rest result^)
                 (== list1 `(,el . ,rest))
                 (conde ((== result `(,el . ,result^))
                         (not-in-listo el list2)
                         (differenceo rest list2 result^))
                        ((membero el list2)
                         (differenceo rest list2 result)))
                 ))))

(define (leto vars cont jexp)
  (fresh (k v rest let-rest)
         (== vars `((,k . ,v) . ,rest))
         (== jexp (jlet k v let-rest))
         (conde ((== rest `())
                 (== let-rest cont))
                ((=/= rest `())
                 (leto rest cont let-rest)))))

(define (begino lst jexp)
  (conde ((== lst `()) (== jexp (jundef)))
         ((== lst `(,jexp)))
         ((fresh (a rest rest-exp)
                 (== lst `(,a . ,rest))
                 (=/= rest `())
                 (== jexp (jbeg a rest-exp))
                 (begino rest rest-exp)
                 ))))

(define (hoist-varo stmt vars)
  (conde ((== vars `())
          (fresh (x) (conde ((== stmt `(return ,x)))
                            ((== stmt `(throw ,x)))
                            ((hoist-var-expo stmt `())))))
         ((fresh (x) (== stmt `(var . ,x)) (hoist-nameso x vars)))
         ((fresh (try-exp catch-exp catch-var)
                 (== stmt `(try ,try-exp catch ,catch-var ,catch-exp))
                 (hoist-var-listo `(,try-exp ,catch-exp) vars)))
         ((fresh (try-exp catch-exp finally-exp catch-var)
                 (== stmt `(try ,try-exp catch ,catch-var ,catch-exp finally ,finally-exp))
                 (hoist-var-listo `(,try-exp ,catch-exp ,finally-exp) vars)))
         ((fresh (cond then else)
                 (== stmt `(if ,cond ,then ,else))
                 (hoist-var-listo `(,then ,else) vars)))
         ((fresh (cond body temp temp^)
                 (== stmt `(while ,cond . ,body))
                 (hoist-var-expo cond temp)
                 (hoist-var-listo body temp^)
                 (appendo temp temp^ vars)))
         ((fresh (exps)
                 (== stmt `(begin . ,exps))
                 (hoist-var-listo exps vars)))
         ((fresh (init cond inc body)
                 (== stmt `(for (,init ,cond ,inc) . ,body))
                 (hoist-var-listo `(,init . ,body) vars)))
         ))

(define (hoist-var-expo stmt vars)
  (fresh (x)
         (== vars `())
         (conde ((== stmt `(number ,x)))
                ((== stmt `(string ,x)))
                ((== stmt `(object . ,x)))
                ((== stmt `(comma . ,x)))
                ((== stmt #t))
                ((== stmt #f))
                ((== stmt (jundef)))
                ((== stmt (jnul)))
                ((symbolo stmt ))
                ((fresh (func args) (== stmt `(call ,func . ,args))))
                ((fresh (erest) (== stmt `(function . ,erest))))
                ((== stmt `(break)))
                ((== stmt `(op . ,x)))
                ((== stmt `(@ . ,x)))
                ((== stmt `(:= . ,x)))))
  )

(define (hoist-var-listo exp-list vars)
  (conde ((== exp-list `()) (== vars `()))
         ((fresh (e erest v vrest)
                 (== exp-list `(,e . ,erest))
                 (hoist-varo e v)
                 (hoist-var-listo erest vrest)
                 (appendo v vrest vars))
          )))

(define (hoist-pairso vars pairs)
  (conde ((== vars `()) (== pairs `()))
         ((fresh (var val name rest v-rest)
                 (== vars `(,var . ,v-rest))
                 (conde ((== var `(,name ,val))
                         (== pairs `((,name ,val) . ,rest)))
                        ((symbolo var)
                         (== pairs rest)))
                 (hoist-pairso v-rest rest)))))

(define (hoist-nameso vars names)
  (conde ((== vars `()) (== names `()))
         ((fresh (var v-rest name val rest)
                 (== vars `(,var . ,v-rest))
                 (== names `(,name . ,rest))
                 (conde ((== var `(,name ,val)))
                        ((symbolo var)
                         (== name var)))
                 (hoist-nameso v-rest rest)))))

(define (pair-assigno pairs jexp env)
  (fresh (var val val^ rest cont)
         (== pairs `((,var ,val) . ,rest))
         (symbolo var)
         (parse-exp-envo val val^ env)
         (conde ((== rest `())
                 (== jexp (jassign (jvar var) val^)))
                ((=/= rest `())
                 (== jexp (jbeg (jassign (jvar var) val^) cont))
                 (pair-assigno rest cont env)
                 ))))

(define (allocato list cont out)
  (conde ((== list `()) (== out cont))
         ((fresh (a rest rest-padded)
                 (== list `(,a . ,rest))
                 (== out (jlet a (jall (jundef)) rest-padded))
                 (allocato rest cont rest-padded)))))

(define (assigno list cont out)
  (conde ((== list `()) (== out cont))
         ((fresh (a b rest -rest rest-padded)
                 (== list `(,a . ,rest))
                 (== out (jlet a (jall (jvar a)) rest-padded))
                 (assigno rest cont rest-padded)))))

(define/match (mknum->num x)
  [((list)) 0]
  [((cons d rest)) (+ d (* 2 (mknum->num rest)))]
  [(_) (begin x)])

(define/match (dehumanize stmt )
  [((? string?)) (jstr stmt )]
  [((? integer?)) (jnum stmt )]
  [((list)) `()]
  [((? list?)) (cons (dehumanize (car stmt )) (dehumanize (cdr stmt )))]
  [(_) stmt ])

(define/match (humanize stmt )
  [((list `string x)) (list->string (map (compose integer->char mknum->num) x))]
  [((list `number x)) (mknum->num x)]
  [((list)) `()]
  [((? list?)) (cons (humanize (car stmt )) (humanize (cdr stmt )))]
  [(_) stmt ])

