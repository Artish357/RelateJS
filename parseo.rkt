#lang racket
(require "js-structures.rkt" "faster-miniKanren/mk.rkt" "evalo.rkt" "helpers.rkt")
(provide pull-varo pull-var-listo pull-pairso humanize dehumanize parseo-h parseo)

(define (parse-envo exp jexp env)
  (conde ((parse-exp-envo exp jexp env)) ;; Expressions
         ((fresh (exps exps^ jexp^) ;; Begin
                 (== exp `(begin . ,exps))
                 (== jexp (jbeg jexp^ (jundef)))
                 (parse-env-listo exps exps^ env)
                 (begino exps^ jexp^)))
         ((fresh (cond then else cond^ then^ else^) ;; if statements
                 (== exp `(if ,cond ,then ,else))
                 (== jexp (jbeg (jif cond^ then^ else^) (jundef)))
                 (parse-env-listo `(,cond ,then ,else) `(,cond^ ,then^ ,else^) env) ;; TODO: simplify to use a custom parser
                 ))
         ((varo exp jexp env)) ;; Var
         ((parse-foro exp jexp env))
         ((switcho exp jexp env))
         ;; different breaks
         ((fresh (val val^)  ;; return
                 (== exp `(return ,val))
                 (== jexp (jthrow `return val^))
                 (parse-exp-envo val val^ env)
                 ))
         ((fresh (val val^)  ;; throw
                 (== exp `(throw ,val))
                 (== jexp (jthrow `error val^))
                 (parse-exp-envo val val^ env)
                 ))
         ((fresh (val)  ;; break
                 (== exp  `(break))
                 (== jexp (jthrow `break (jundef)))))
         ((fresh (try-exp catch-exp try-exp^ catch-exp^ label env^) ;; Try/catch
                 (== exp `(try ,try-exp catch ,label ,catch-exp))
                 (== jexp (jbeg (jcatch `error try-exp^ label
                                  (jlet label (jall (jvar label)) catch-exp^)) (jundef)))
                 (== env^ `(,label . ,env))
                 (parse-env-listo `(,try-exp ,catch-exp) `(,try-exp^ ,catch-exp^) env^)))
         ((fresh (try-exp try-exp^  finally-exp finally-exp^) ;; Try/finally
                 (== exp `(try ,try-exp finally ,finally-exp))
                 (== jexp (jfin try-exp^ (jbeg finally-exp^ (jundef))))
                 (parse-env-listo `(,try-exp ,finally-exp) `(,try-exp^ ,finally-exp^) env)
                 ))
         ((fresh (try-exp catch-exp try-exp^ catch-exp^ finally-exp finally-exp^ label env^) ;; Try/catch/finally
                 (== exp `(try ,try-exp catch ,label ,catch-exp finally ,finally-exp))
                 (== jexp (jbeg (jcatch `error try-exp^ label catch-exp^) (jbeg finally-exp^ (jundef))))
                 (== env^ `(,label . ,env))
                 (parse-env-listo `(,try-exp ,catch-exp ,finally-exp) `(,try-exp^ ,catch-exp^ ,finally-exp^) env^)))
         ((fresh (cond body cond^ body^ body^^) ;; while statements
                 (== exp `(while ,cond . ,body))
                 (== jexp (jcatch `break (jwhile cond^ body^^) `e (jundef)))
                 (parse-exp-envo cond cond^ env)
                 (parse-envo body body^ env) ;; TODO: vars introduced in head are not in env
                 (begino body^ body^^)
                 ))
         ))

(define (parse-exp-envo exp jexp env)
  (conde ;; primitive values
   ((== exp jexp)(fresh (x) (conde ((== exp `(number ,x)))
                                   ((== exp `(string ,x))))))
   ((== exp #t) (== jexp (jbool #t)))
   ((== exp #f) (== jexp (jbool #f)))
   ((symbolo exp) (== jexp (jderef (jvar exp))))
   ((== exp (jundef)) (== jexp (jundef)))
   ((== exp (jnul)) (== jexp (jnul)))
   ((objecto exp jexp env))
   ((functiono exp jexp env)) ;; Functions
   ((fresh (func args func^ args^) ;; Function call
           (== exp `(call ,func . ,args))
           (== jexp (jcatch `return (japp (jget (jget (jderef func^) (jstr "private")) (jstr "call")) args^) `result (jvar `result)))
           (parse-exp-env-listo `(,func . ,args) `(,func^ . ,args^) env)
           ))
   ((fresh (val val^ index index^) ;; Field getter
           (== exp `(@ ,val ,index))
           (== jexp (jget (jget (jderef val^) (jstr "public")) index^))
           (parse-exp-env-listo `(,val ,index) `(,val^ ,index^) env)
           ))
   ((fresh (var val var^ val^) ;; Assignment
           (== exp `(:= ,var ,val))
           (conde ((symbolo var) (== jexp (jassign (jvar exp) val^)))
                  ((fresh (obj obj^ key key^ obj-parsed temp-var)
                          (== var `(@ ,obj ,key))
                          (== obj-parsed (jvar obj))
                          (symbolo temp-var)
                          (not-in-listo temp-var env)
                          (== jexp (jbeg
                                    (jlet
                                     temp-var
                                     (jset (jderef obj^) (jstr "public") (jset (jget (jderef obj^) (jstr "public")) key^ val^))
                                     (jassign obj^ (jvar temp-var)))
                                    val^))
                          (parse-exp-env-listo `(,key ,obj) `(,key^ ,obj^) env))))
           (parse-exp-envo val val^ env)
           ))
   ((fresh (op vals vals^) ;; Basic operations
           (== exp `(op ,op . ,vals))
           (== jexp (jdelta op vals^))
           (parse-exp-env-listo vals vals^ env)
           ))
   ((fresh (exps exps^) ;; Comma
           (== exp `(comma . ,exps))
           (parse-exp-env-listo exps exps^ env)
           (begino exps^ jexp)))
   ))

(define (parse-foro exp jexp env)
  (fresh (init init^ cond cond^ inc inc^ body body^ body^^)
         (== exp `(for (,init ,cond ,inc) . ,body))
         (== jexp (jbeg init^ (jcatch `break (jwhile cond^ (jbeg body^^ inc^)) `e (jundef))))
         (parse-exp-env-listo `(,cond . ,inc) `(,cond^ . ,inc^) env)
         (parse-env-listo `(,init . ,body) `(,init^ . ,body^) env)
         (begino body^ body^^)
         ))

(define (parse-env-listo lst jlst env)
  (conde ((== lst `()) (== jlst `()))
         ((fresh (p p^ rest rest^)
                 (== lst `(,p . ,rest))
                 (== jlst `(,p^ . ,rest^))
                 (parse-envo p p^ env)
                 (parse-env-listo rest rest^ env)
                 ))))

(define (parse-exp-env-listo lst jlst env)
  (conde ((== lst `()) (== jlst `()))
         ((fresh (p p^ rest rest^)
                 (== lst `(,p . ,rest))
                 (== jlst `(,p^ . ,rest^))
                 (parse-exp-envo p p^ env)
                 (parse-exp-env-listo rest rest^ env)
                 ))))

(define (parseo-h exp jexp) (parseo (dehumanize exp) jexp))

(define (parseo exp jexp)
  (fresh (vars exp^ allocations body)
         (pull-varo exp vars)
         (allocato vars body jexp)
         (parse-envo exp body vars)))

(define (lh-parseo exp jexp env)
  (conde ((symbolo exp) (== jexp (jvar exp)))
         ((fresh (obj obj^ val val^)
                 (== exp `(@ ,obj ,val))
                 (== jexp (jget (jget obj^ (jstr "public")) val^))
                 (parse-exp-env-listo `(,obj ,val) `(,obj^ ,val^) env)
                 ))))


(define (objecto exp jexp env)
  (fresh (pairs public)
         (== exp `(object . ,pairs))
         (== jexp (jall (jset (jobj (list (cons (jstr "private") (jobj `())))) (jstr "public") public)))
         (object-helpero pairs public env)
         ))

(define (object-helpero exp-binds jexp env)
  (conde ((== exp-binds `()) (== jexp (jobj `())))
         ((fresh (key val key^ val^ rest prev curr)
                 (== exp-binds `((,key ,val) . ,rest))
                 (== jexp (jset prev key^ val^))
                 (parse-exp-env-listo `(,key ,val) `(,key^ ,val^) env)
                 (object-helpero rest prev env)))))

(define (varo exp jexp env)
  (fresh (vars pairs jexp^)
         (== exp `(var . ,vars))
         (pull-pairso vars pairs)
         (conde ((== pairs `()) (== jexp (jundef)))
                ((== jexp (jbeg jexp^ (jundef)))
                 (=/= pairs `())
                 (pair-assigno pairs jexp^ env)
                 ))))

(define (functiono exp jexp env)
  (fresh (params body body^ body^^ body^^^ body^^^^ vars vars^ payload env^ env^^)
         (== exp `(function ,params . ,body))
         (== jexp (jall (jset (jobj `((,(jstr "public") . ,(jobj `()))))
                              (jstr "private")
                              (jset (jobj `()) (jstr "call") (jfun params (jbeg body^^^^ (jundef)))))))
         (pull-var-listo body vars)
         (differenceo vars params vars^)
         (appendo vars^ env env^)
         (appendo params env^ env^^)
         (parse-env-listo body body^ env^^)
         (begino body^ body^^)
         (allocato vars^ body^^ body^^^)
         (assigno params body^^^ body^^^^)
         ))

(define (differenceo list1 list2 result)
  (conde ((== list1 `())
          (== result list1))
         ((fresh (el rest result^)
                 (== list1 `(,el . ,rest))
                 (conde ((== result `(,el . ,result^))
                         (not-in-listo el list2)
                         (differenceo rest list2 result^))
                        ((membero el list2)
                         (differenceo rest list2 result)))
                 ))))

(define (leto vars cont jexp)
  (fresh (k v rest let-rest)
         (== vars `((,k . ,v) . ,rest))
         (== jexp (jlet k v let-rest))
         (conde ((== rest `())
                 (== let-rest cont))
                ((=/= rest `())
                 (leto rest cont let-rest)))))

(define (begino lst jexp)
  (conde ((== lst `()) (== jexp (jundef)))
         ((== lst `(,jexp)))
         ((fresh (a rest rest-exp)
                 (== lst `(,a . ,rest))
                 (=/= rest `())
                 (== jexp (jbeg a rest-exp))
                 (begino rest rest-exp)
                 ))))

(define (switcho exp jexp env)
  (fresh (pairs val val^ jexp^)
         (== exp `(switch ,val . ,pairs))
         (== jexp (jbeg jexp^ (jundef)))
         (parse-exp-envo val val^ env)
         (switch-helpero pairs val^ jexp^ env)))

(define (switch-helpero pairs val jexp env)
  (conde ((== pairs `())
          (== jexp (jundef)))
         ((fresh (target body target^ body^ rest rest-exp)
                 (== pairs `((,target ,body) . ,rest))
                 (== jexp (jif (jdelta `=== `(,val ,target^)) body^ rest-exp))
                 (parse-exp-envo target target^ env)
                 (parse-envo body body^ env)
                 (switch-helpero rest val rest-exp env)))))

(define (pull-varo exp vars)
  (conde ((== vars `())
          (fresh (x) (conde ((== exp `(return ,x)))
                            ((== exp `(throw ,x)))
                            ((pull-var-expo exp `())))))
         ((fresh (x) (== exp `(var . ,x)) (pull-nameso x vars)))
         ((fresh (try-exp catch-exp label)
                 (== exp `(try ,try-exp catch ,label ,catch-exp))
                 (pull-var-listo `(,try-exp ,catch-exp) vars)))
         ((fresh (try-exp catch-exp finally-exp label)
                 (== exp `(try ,try-exp catch ,label ,catch-exp finally ,finally-exp))
                 (pull-var-listo `(,try-exp ,catch-exp ,finally-exp) vars)))
         ((fresh (cond then else)
                 (== exp `(if ,cond ,then ,else))
                 (pull-var-listo `(,then ,else) vars)))
         ((fresh (cond body temp temp^)
                 (== exp `(while ,cond . ,body))
                 (pull-var-expo cond temp)
                 (pull-var-listo body temp^)
                 (appendo temp temp^ vars)))
         ((fresh (t x)
                 (== exp `(switch ,t . ,x))
                 (pull-var-switcho x vars)))
         ((fresh (exps)
                 (== exp `(begin . ,exps))
                 (pull-var-listo exps vars)))
         ((fresh (init cond inc body)
                 (== exp `(for (,init ,cond ,inc) . ,body))
                 (pull-var-listo `(,init . ,body) vars)))
         ))

(define (pull-var-switcho switch vars)
  (conde ((== switch `()) (== vars `()))
         ((fresh (case code rest v v2)
                 (== switch `((,case ,code) . ,rest))
                 (pull-varo code v)
                 (appendo v v2 vars)
                 (pull-var-switcho rest v2)))))

(define (pull-var-expo exp vars)
  (fresh (x)
         (== vars `())
         (conde ((== exp `(number ,x)))
                ((== exp `(string ,x)))
                ((== exp `(object . ,x)))
                ((== exp `(comma . ,x)))
                ((== exp #t))
                ((== exp #f))
                ((== exp (jundef)))
                ((== exp (jnul)))
                ((symbolo exp))
                ((fresh (func args) (== exp `(call ,func . ,args))))
                ((fresh (erest) (== exp `(function . ,erest))))
                ((== exp `(break)))
                ((== exp `(op . ,x)))
                ((== exp `(@ . ,x)))
                ((== exp `(:= . ,x)))))
  )

(define (pull-var-listo exp-list vars)
  (conde ((== exp-list `()) (== vars `()))
         ((fresh (e erest v vrest)
                 (== exp-list `(,e . ,erest))
                 (pull-varo e v)
                 (pull-var-listo erest vrest)
                 (appendo v vrest vars))
          )))

(define (pull-pairso vars pairs)
  (conde ((== vars `()) (== pairs `()))
         ((fresh (var val name rest v-rest)
                 (== vars `(,var . ,v-rest))
                 (conde ((== var `(,name ,val))
                         (== pairs `((,name ,val) . ,rest)))
                        ((symbolo var)
                         (== pairs rest)))
                 (pull-pairso v-rest rest)))))

(define (pull-nameso vars names)
  (conde ((== vars `()) (== names `()))
         ((fresh (var v-rest name val rest)
                 (== vars `(,var . ,v-rest))
                 (== names `(,name . ,rest))
                 (conde ((== var `(,name ,val)))
                        ((symbolo var)
                         (== name var)))
                 (pull-nameso v-rest rest)))))

(define (pair-assigno pairs jexp env)
  (fresh (var val val^ rest cont)
         (== pairs `((,var ,val) . ,rest))
         (symbolo var)
         (parse-exp-envo val val^ env)
         (conde ((== rest `())
                 (== jexp (jassign (jvar var) val^)))
                ((=/= rest `())
                 (== jexp (jbeg (jassign (jvar var) val^) cont))
                 (pair-assigno rest cont env)
                 ))))

(define (allocato list cont out)
  (conde ((== list `()) (== out cont))
         ((fresh (a rest rest-padded)
                 (== list `(,a . ,rest))
                 (== out (jlet a (jall (jundef)) rest-padded))
                 (allocato rest cont rest-padded)))))

(define (assigno list cont out)
  (conde ((== list `()) (== out cont))
         ((fresh (a b rest -rest rest-padded)
                 (== list `(,a . ,rest))
                 (== out (jlet a (jall (jvar a)) rest-padded))
                 (assigno rest cont rest-padded)))))

(define/match (mknum->num x)
  [((list)) 0]
  [((cons d rest)) (+ d (* 2 (mknum->num rest)))]
  [(_) (begin x)])

(define/match (dehumanize exp)
  [((? string?)) (jstr exp)]
  [((? integer?)) (jnum exp)]
  [((list)) `()]
  [((? list?)) (cons (dehumanize (car exp)) (dehumanize (cdr exp)))]
  [(_) exp])

(define/match (humanize exp)
  [((list `string x)) (list->string (map (compose integer->char mknum->num) x))]
  [((list `number x)) (mknum->num x)]
  [((list)) `()]
  [((? list?)) (cons (humanize (car exp)) (humanize (cdr exp)))]
  [(_) exp])

